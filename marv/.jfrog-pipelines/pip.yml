template: true
valuesFilePath: ./values.yml

installCdk: &INSTALL_CDK
  onStart:
  - sudo apt update
  - curl -sL https://deb.nodesource.com/setup_16.x | sudo bash -
  - sudo apt install nodejs
  - node --version
  - npm install -g aws-cdk
  - cdk version

installHugo: &INSTALL_HUGO
  onStart:
  - >
    curl -Lks https://github.com/gohugoio/hugo/releases/download/v${hugoVersion}/hugo_extended_${hugoVersion}_Linux-64bit.deb
    -o $step_tmp_dir/hugo.deb
  - dpkg -i $step_tmp_dir/hugo.deb
  - hugo version

resources:
  - name: {{.Values.pipeline.name}}_DeploymentSpec
    type: PropertyBag
    configuration:
      TEST: 1
  - name: {{.Values.pipeline.name}}_Functions
    type: PropertyBag
    configuration:
      TEST: 1
  - name: {{.Values.pipeline.name}}_DeploymentPackage
    type: PropertyBag
    configuration:
      TEST: 1
  - name: {{.Values.pipeline.name}}_BuildInfo
    type: PropertyBag
    configuration:
      TEST: 1


pipelines:
- name: {{.Values.pipeline.name}}_Deployment
  configuration:
    retentionPolicy:
      maxAgeDays: 1
      minRuns: 10
    jfrogCliVersion: 2
    environmentVariables:
      readOnly:
        JFROG_CLI_PLUGINS_SERVER: s_artifactory
        JFROG_CLI_BUILD_NUMBER: ${run_id}
    runtime:
      type: image
      image:
        custom:
          name: releases-docker.jfrog.io/jfrog/pipelines-u20java
          tag: '{{.Values.javaVersion}}'
  steps:
  - name: setup_deployment
    type: Bash
    configuration:
      integrations:
      - name: s_artifactory
      inputResources:
      - name: {{.Values.pipeline.name}}_DeploymentSpec
      outputResources:
      - name: {{.Values.pipeline.name}}_DeploymentPackage
    execution:
      onExecute:
      - packagePatternPath="{{.Values.deployments.repo}}/${targetEnvironment}/"
      - jfrog rt mv --insecure-tls=${no_verify_ssl} --flat=true "${sourcePackagePattern}" "${packagePatternPath}"
      - add_run_variables "packagePatternPath=${packagePatternPath}" "targetEnvironment=${targetEnvironment}"
      - write_output {{.Values.pipeline.name}}_DeploymentPackage "pattern=${packagePatternPath}/${sourcePackagePattern}"
  - name: prepare_deployment
    type: Bash
    configuration:
      inputResources:
      - name: {{.Values.pipeline.name}}_Functions
      - name: {{.Values.pipeline.name}}_DeploymentPackage
    execution:
      <<: *INSTALL_CDK
      onExecute:
      - pushd $(find_resource_variable "{{.Values.pipeline.name}}_DeploymentPackage" resourcePath)

      - tar -xzf cdk-package.tar.gz

      - eval "$(jq -c .app --raw-output cdk.json) ${targetEnvironment}"
      - add_run_files cdk.context.json cdk.context.json

      - add_run_variables environmentName="$(jq -c '."environment.name"' --raw-output cdk.context.json)"
      - add_run_variables environmentNameLowercase="${environmentName,,}"
      - >
        stackName=$(jq -c '."bootstrap.stack.name"' --raw-output cdk.context.json);
        qualifier=$(jq -c '."bootstrap.qualifier"' --raw-output cdk.context.json);
        echo "cdk bootstrap --toolkit-stack-name '${stackName}' --qualifier '${qualifier}' --termination-protection";
        cdk bootstrap --toolkit-stack-name "${stackName}" --qualifier "${qualifier}" --termination-protection

      - >
        docsBaseUrl=$(cdk synth "*-DocumentationStack" --json | jq -c .Outputs.ADDONDOCSBASEURLOutput.Value --raw-output);
        add_run_variables docsBaseUrl="${docsBaseUrl}"

      - popd
  - name: generate_docs
    type: Bash
    configuration:
      environmentVariables:
        hugoVersion: '1.0.0'
      inputSteps:
      - name: prepare_deployment
      inputResources:
      - name: {{.Values.pipeline.name}}_Functions
      - name: {{.Values.pipeline.name}}_DeploymentPackage
        trigger: false
      runtime:
        type: image
        image:
          custom:
            name: releases-docker.jfrog.io/jfrog/pipelines-u20go
            tag: '1.18'
    execution:
      <<: *INSTALL_HUGO
      onExecute:
      - pushd $(find_resource_variable "{{.Values.pipeline.name}}_DeploymentPackage" resourcePath)

      - tar -xzf docs-package.tar.gz

      - git config --system user.name 'Cave Groundskeeper'
      - git config --system user.email 'cave@marvelution.com'
      - git config --system url.ssh://git@bitbucket.org/.insteadOf https://bitbucket.org/
      - >
        echo "Host bitbucket.org
            StrictHostKeyChecking no
            IdentityFile ~/.ssh/{{.Values.docs.sshKey}}" >> ~/.ssh/config
      - cat ~/.ssh/config

      - echo "Generating documentation for environment ${environmentNameLowercase} with base url ${docsBaseUrl}"
      - hugo --environment=${environmentNameLowercase} --baseURL "${docsBaseUrl}" --verbose ${HUGO_OPTS}

      - tar -czf docs.tar.gz -C ./public/ .
      - add_run_files docs.tar.gz docs.tar.gz

      - popd
  - name: perform_deployment
    type: Bash
    configuration:
      integrations:
      - name: s_artifactory
      inputSteps:
      - name: prepare_deployment
      - name: generate_docs
      inputResources:
      - name: {{.Values.pipeline.name}}_Functions
      - name: {{.Values.pipeline.name}}_DeploymentPackage
        trigger: false
      - name: {{.Values.pipeline.name}}_BuildInfo
        trigger: false
    execution:
      <<: *INSTALL_CDK
      onExecute:
      - pushd $(find_resource_variable "{{.Values.pipeline.name}}_DeploymentPackage" resourcePath)

      - tar -xzf cdk-package.tar.gz

      - restore_run_files docs.tar.gz $step_tmp_dir/docs.tar.gz
      - tar -xzf $step_tmp_dir/docs.tar.gz -C ./resources/docs

      - restore_run_files cdk.context.json cdk.context.json
      - cdk deploy --all --verbose $CDK_OPTIONS

      - >
        jfrog rt bpr --status ${environmentNameLowercase} \
          ${res_{{.Values.pipeline.name}}_BuildInfo_buildName} \
          ${res_{{.Values.pipeline.name}}_BuildInfo_buildNumber}

      - tar -czf deployment.tar.gz cdk.out cdk.json cdk.context.json
      - >
        jfrog rt upload \
          --target-props="deployment.name={{.Values.pipeline.name}};deployment.number=${run_number};deployment.branch={{gitBranch}}" \
          ./deployment.tar.gz "{{.Values.deployments.repo}}/${environmentNameLowercase}/deployment-${run_number}.tar.gz"

      # TODO If this is a deployment to staging or production, then also do a Marketplace version update with release notes.

      - popd
  - name: promote_deployment
    type: Bash
    configuration:
      condition: '"{{gitBranch}}" == "master"'
      requiresApproval:
        # Timeout in 1 week
        timeoutSeconds: 604800
      integrations:
      - name: s_artifactory
      inputSteps:
      - name: perform_deployment
      outputResources:
      - name: {{.Values.pipeline.name}}_DeploymentSpec
    execution:
      onExecute:
      - task: release-jira-version@v0.0.1
        input:
          jira: {{.Values.versioning.jira}}
          projectKey: {{.Values.versioning.project}}
          version: '${run_id}'
          versionPrefix: 'connect-'
          optional: true
      - write_output {{.Values.pipeline.name}}_DeploymentSpec "targetEnvironment=production" "sourcePackagePath=${packagePatternPath}"
        
        {{if eq "{{gitBranch}}" "master"}}
- name: {{.Values.pipeline.name}}_Cleanup
  configuration:
    retentionPolicy:
      maxAgeDays: 1
      minRuns: 10
    jfrogCliVersion: 2
    environmentVariables:
      readOnly:
        JFROG_CLI_PLUGINS_SERVER: s_artifactory
        JFROG_CLI_BUILD_NUMBER: ${run_id}
    runtime:
      type: image
      image:
        custom:
          name: releases-docker.jfrog.io/jfrog/pipelines-u20java
          tag: '{{.Values.javaVersion}}'
  steps:
  - name: cleanup_deployment
    type: Bash
    configuration:
      integrations:
      - name: s_artifactory
      inputResources:
      - name: {{.Values.pipeline.name}}_CleanupGitRepo
      - name: {{.Values.pipeline.name}}_Functions
    execution:
      <<: *INSTALL_CDK
      onExecute:
      - |
        if [ "$res_{{.Values.pipeline.name}}_CleanupGitRepo_isBranchDelete" == "true" ]; then
          branch="$res_{{.Values.pipeline.name}}_CleanupGitRepo_branchName"
        fi
      - |
        if [ ! -z "$branch" ]; then
          jfrog rt download --sort-by=created --sort-order=desc --limit=1 --flat=true \
            --props="deployment.name={{.Values.pipeline.name}};deployment.branch=${branch}" \
            "{{.Values.deployments.repo}}/${branch}/deployment-*.tar.gz" ./deployment.tar.gz
          if [ -f ./deployment.tar.gz ]; then
            echo "Destroying deployment for branch ${branch}"
            tar -xzf ./deployment.tar.gz
            cdk destroy --app cdk.out --all --verbose --force
          fi
        
          echo "Deleting deployment packages for ${branch}"
          jfrog rt delete --props="deployment.name={{.Values.pipeline.name}};deployment.branch=${branch}" "{{.Values.deployments.repo}}/"
        fi   
        {{end}}
